@NAME CFW Wick Parser

@EXT wick

@SYMBOL </ 

@IGNORE θws θnl

@IMPORT ../../../node_modules/@candlefw/js/source/grammar/ecmascript.hcg as js

@IMPORT ./wickup.hcg as wickup

@IMPORT ./html.hcg as html

@IMPORT ../../../node_modules/@candlefw/css/source/grammar/css.hcg as css 

<> S → start																				↦r{ $sym1 }

<> start → html::HTML
	 │ js::javascript 

+> js::statement → html::GOAL_TAG ;  	  													↦r { $sym1 }

+> html::BODY →  IMPORT_TAG(+) html::GOAL_TAG 												↦return { $sym2.import_list = $sym1, $sym2}
	
+> html::TAG → < τstyle html::ATTRIBUTES? >  css::CSS  </ τstyle > 							↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
	│ < τscript html::ATTRIBUTES? > js::script? </ τscript > 								↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
	│ < τjs html::ATTRIBUTES? > js::script? </ τjs > 										↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
	│ \{ js::expression \{ js::script? \} \}												↦r {fn.element_selector("script", ["on", null, new env.wick_binding(["on",null, $sym2])], $sym4, env, lex) }



<> IMPORT_TAG → < τimport html::ATTRIBUTES /? > (</ τimport>)?  							↦return { fn.element_selector($$sym2, $$sym3, null,  env, lex ) }


+> html::VOID_NAME → τimport
		│ τlink
		│ τf
		│ τfilter

+> html::ATTRIBUTE_BODY → WICK_BINDING 									
	│ " WICK_BINDING " 																		↦return { $sym2 }

 +> html::TEXT_NODE → WICK_BINDING 															↦cstr ^text


<> WICK_BINDING → CALL_BINDING  							
 	│ BASIC_BINDING
 
<> BASIC_BINDING → \( (ERR θws ) \( ↦{ env.start = lex.off+2 } js::expression \) (ERR θws ) \)   							↦cstr ^wick_binding
<> CALL_BINDING → \( (ERR θws ) \( ↦{ env.start = lex.off+2 } js::expression \) (ERR θws ) \( js::expression \) (ERR θws ) \)    	↦cstr ^wick_binding
